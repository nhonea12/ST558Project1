---
title: "ST 558 Project 1"
author: "Nathan Honea and Ramya Konduru"
format: html
editor_options: 
  chunk_output_type: console
---

```{r setup code chunk}
library(tidyverse)
library(DBI)
```

# Read in Data from API

We want to create a function that will pull real data directly from the Census Bureauâ€™s ACS PUMS API. This function, called get_census_data(), allows us to pick the survey year, numeric variables, and categorical variables we are interested in. The function cleans the output so numeric variables are stored as numbers, categorical variables are stored as factors, and the weight variable (PWGTP) is always included. We also add a "census" class to the tibble so our custom summary and plot functions can use it later. By calling this function, we are able to quickly pull live census data into R for analysis.


```{r}
library(httr)
library(jsonlite)
library(dplyr)

get_census_data <- function(year = 2022,
                            num_vars = c("AGEP", "PWGTP"), 
                            cat_vars = c("SEX"),
                            state = "17") {   # default: Illinois (Group 17)
  
  if (year < 2010 | year > 2022) {
    stop("Year must be between 2010 and 2022")
  }
  
  if (!"PWGTP" %in% num_vars) {
    num_vars <- c(num_vars, "PWGTP")
  }
  
  base_url <- sprintf("https://api.census.gov/data/%s/acs/acs1/pums", year)
  vars <- paste(c(num_vars, cat_vars), collapse = ",")
  
  # Build query properly
  query <- list(get = vars, `for` = paste0("state:", state))
  
  res <- GET(base_url, query = query)
  stop_for_status(res)
  
  dat <- fromJSON(content(res, "text"))
  
  df <- as.data.frame(dat[-1, ], stringsAsFactors = FALSE)
  names(df) <- dat[1, ]
  
  for (v in num_vars) {
    df[[v]] <- as.numeric(df[[v]])
  }
  
  for (v in cat_vars) {
    df[[v]] <- as.factor(df[[v]])
  }
  
  df <- tibble::as_tibble(df)
  class(df) <- c("census", class(df))
  
  return(df)
}

# Pull the data
test <- get_census_data()
cat("Pulled census data with", nrow(test), "rows\n")
head(test)

```

The function essentially connects to the census data through API calls, tests the connection and return "Pulled Census data with _ rows" with the number of data rows pulled. It is also important to note that we are only pulling in data from **State 17** as we are group 17. 

# Generalized functions

## Summary function

We want to create a function a generic function for summarizing our data. A generic function will return different outputs for different classes given in the input. Our generic function will return weighted means and standard deviations given numeric variables from a tibble, and return counts in a one-way frequency table given categorical variables in from a tibble. We have given default values for our function, so it still returns summaries even when no arguments are given! Our function defaults to using our tibble where we have added `"census"` as a class. The default numeric variables that the function summarizes is every numeric variable except PWGTP (which is our weights), and the default categorical variables used are every categorical variable in our tibble. The values are returned in a list of length 2, with the first object in the list being our numeric summaries and the second object being the categorical summaries.

```{r}
# create a function to get weighted summary statistics of variables from our census data, with the PWGTP variable being our weight
summary.census <- function(tibble = test, 
                           num_vars = names(tibble |> 
                             select(where(is.numeric), -PWGTP)), 
                           cat_vars = names(tibble |> 
                             select(where(is.factor)))){
  
  num_list <- tibble |> 
    summarize(across(all_of(num_vars),
            list("mean" = ~ weighted.mean(.x, w = tibble$PWGTP, na.rm = TRUE), 
                 "sd"   = ~ sqrt(weighted.mean((.x - weighted.mean(.x, tibble$PWGTP))^2, 
                                              w = tibble$PWGTP))),
            .names = "{.fn}_{.col}"))
  
  cat_list <- tibble |> 
    group_by(across(all_of(cat_vars))) |>
    summarize(weighted_count = sum(PWGTP))
  
  return(list(num_list, cat_list))
}

# Run summary
summary(test)
summary.census()

```

This function provides weighted descriptive statistics for the numeric variables (mean and standard deviation) and frequency counts for the categorical variables. This allows us to quickly see the distribution of values in our dataset while properly accounting for census weights.

## Plot function

We also want to create a generic function for plotting our variables, specifically a box plot of a numeric variable grouped by a categorical variable. Our default data set is again the tibble with `"census"` as a class, but we have no default variables, so the user must specify them when calling the function. The tibble, numeric variable (titled `num_var` where we define our function), and categorical variable (titled `cat_var`) are the three arguments in our function. Once again, our numeric variable is being weighted, still by the `PWGTP` variable. The function will produce side-by-side box plots, with the number of box plots produced being the number of of levels to our categorical variable.

```{r}

plot.census <- function(tibble = test, num_var, cat_var){
  ggplot(tibble, aes(x = get(cat_var), y = get(num_var), weight = PWGTP)) +
    geom_boxplot()
}

# Example plot
plot(test, num_var = "AGEP", cat_var = "SEX")

```
This function gives a quick visual comparison of the numeric variable across groups of the categorical variable. For example, plotting AGEP by SEX shows the distribution of ages for males and females in our subset of the Census data.